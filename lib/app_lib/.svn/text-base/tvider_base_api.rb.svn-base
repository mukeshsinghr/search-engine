module Tvider
  module TviderBaseApi

    def initialize
      @errors = []
      @response = {:code => 0, :result => nil}
      @page_limit = 20
      @popular_page_limit = 15
      @api_authenticated_user = nil

      @response_codes =
              {
                      :success => 0,
                      :internal_error => 10,
                      :validation_error => 11,
                      :insufficient_params => 12,
                      :auth_error => 20,
                      :incorrect_auth => 21,
                      :unauthorized => 22,
                      :incorrect_user => 23,
                      :incorrect_pass => 24,
                      :signup_success => 25,
                      :signup_failure => 26,
                      :change_password_failure => 28,
                      :twitter_link_failure => 27,
											:facebook_link_failure => 29,
                      :chunk_init_success => 30,
                      :chunk_init_failed => 31,
                      :upload_in_progress => 32,
                      :upload_success => 33,
                      :upload_failed => 34,
                      :no_status_found => 40,
                      :no_comments_found => 51,
                      :multiple_errors => 99,
											:facebook_unlink_success =>35,
											:facebook_unlink_fail =>36,
											:twitter_unlink_success => 37,
											:twitter_unlink_fail =>38


              }

      @response_messages =
              {
                      :internal_error => "Booooo Aaaaahhhh! Something went wrong while processing your request.",
                      :auth_error => "Authorization credentials are missing!!",
                      :incorrect_auth => "Your username and password combination is incorrect.",
                      :incorrect_user => "Your username is not signed-up with us.",
                      :incorrect_pass => "Your password is incorrect.",
                      :unauthorized => "Access Denied!! You are not authorised to access this information.",
                      :signup_success => "Hurray! User successfully signed up!",
                      :signup_failure => "Balderdash! Errors in signup",
                      :chunk_init_success => "File upload in chunk is successfully initialised.",
                      :chunk_init_failed => "Initialization of file upload in chunks failed.",
                      :upload_in_progress => "File upload in chunk formats is in progress.",
                      :upload_success => "File is successfully uploaded.",
                      :upload_failed => "File upload is permanently failed.",
                      :upload_invalid_file => "Selected file is not a multimedia content.",
                      :no_status_found => "No status(es) were found for your criteria. May be deleted.",
                      :twitter_linked => "Twitter account was successfully linked!",
											:facebook_linked => "Facebook account was successfully linked!",
                      :twitter_link_failure => "Twitter account linking failed.",
											:facebook_link_failure => "Facebook account linking failed.",
                      :no_comments_found => "No comments were found for given tweet.",
                      :comment_delete_success => "Comment deleted successfully.",
                      :status_delete_success => "Tweet deleted successfully. ",
                      :change_password_success => "Password is successfully changed.",
                      :change_password_failure => "Change Password failed.",
											:facebook_unlink_success => "Facebook account was successfully unlinked!",
											:facebook_unlink_fail => "Facebook account unlinking failed.",
											:twitter_unlink_success => "Twitter account was successfully unlinked!",
											:twitter_unlink_fail => "Twitter account unlinking failed.",
              }
    end


    # Method to check whether the required parameters
    # for the execution of the api are present in the
    # request else it would be erroneous
    def required_params_present?(params, * parameters)
      parameters.each do |param|
        if params[param].blank?
          @response[:code] = @response_codes[:insufficient_params]
          @errors << "#{param.to_s.capitalize!} cannot be left blank"
        end
      end

      @errors.blank? ? true : false
    end


    # Authenticate the api call with a valid user
    # using HTTP authentication mechanism
    def request_api_http_auth
      if @api_authenticated_user = authenticate_with_http_basic { |u, p| authenticate_user_creds(u, p) }
        puts("@api_authenticated_user:#{@api_authenticated_user.username}")
        @api_authenticated_user
      else
        unless @response[:code] == @response_codes[:incorrect_user] or @response[:code] == @response_codes[:incorrect_pass]
          @response[:code] = @response_codes[:auth_error]
          @errors << @response_messages[:auth_error]
        end
      end
    end


    # Authenticate the api call with authorization as
    # a hidden form parameter
    def form_hidden_auth(auth_creds)
      credentials = ActiveSupport::Base64.decode64(auth_creds.split(' ', 2).last || '').split(/:/, 2)
      @api_authenticated_user = authenticate_user_creds(credentials[0], credentials[1])

      unless @api_authenticated_user
        unless @response[:code] == @response_codes[:incorrect_user] or @response[:code] == @response_codes[:incorrect_pass]
          @response[:code] = @response_codes[:auth_error]
          @errors << @response_messages[:auth_error]
          return false
        end
      end

      return true
    end


    # Method to verify the given credentials with
    # the credentials saved in our User model & db
    def authenticate_user_creds(u, p)
      if user = User.find_by_username(u)
        if user.valid_password?(p)
          user
        else
          @response[:code] = @response_codes[:incorrect_pass]
          @errors << @response_messages[:incorrect_pass]
          return nil
        end
      else
        @response[:code] = @response_codes[:incorrect_user]
        @errors << @response_messages[:incorrect_user]
        return nil
      end
    end

		# Create a response for opular member
		def response_popular_member_status(status, profile, user = false)
		
      resp_status = {:user_name => nil, :user_avatar => nil}
			resp_status[:user_name] = status.user.username
			@user_profile_avatar = UserProfileAvatar.find_by_user_id(status.user.id)

     			if !@user_profile_avatar.blank?				
						resp_status[:user_avatar] = @user_profile_avatar.user_avatar.url(:thumb)
					else
						resp_status[:user_avatar] = DEFAULT_THUMBNAIL_URL

					end
			return resp_status
		end

		# Method for response for popular member
		def response_popular_member(statuses, profile, user = false)
      resp = []
      statuses.each do |status|
				if !status.user_id.blank?
        	resp << response_popular_member_status(status, profile, user)
					
				end
      end
      return resp


		end
    # Create a response status-update hash
    def response_status(status, profile, user = false)

      twitter_status = TwitterStatusUpdate.find_by_status_update_id(status.id)
      facebook_status = FacebookStatusUpdate.find_by_status_update_id(status.id)
    
#       comment_count = StatusComments.count(:conditions => "status_update_id = #{status.id}")

      resp_status = {:media => {}, :text => nil, :id => nil,
                     :twitter_status_id => nil, :facebook_status_id => nil, :user => nil,
                     :comments_count => nil, :abuse => nil, :favorite => nil, :created_at => nil,
                     :state =>nil, :deletable => false, :favoritable => false, :views => nil,:ontwitter=>false,:onfacebook =>false}
      resp_status[:id] = status.id
      resp_status[:text] = status.text
      resp_status[:user] = response_user(status.user)
#       resp_status[:comments_count] = comment_count
#       resp_status[:abuse] = status.abuse
      resp_status[:created_at] = status.created_at
#       resp_status[:state] = status.state
#       resp_status[:favorite] = status.favorite
#       resp_status[:views] = status.views

# add thids line check the status for each post in FB/twitter
			if !twitter_status.blank?
				resp_status[:ontwitter] = true
			end
			if !facebook_status.blank?
				resp_status[:onfacebook] = true
			end



#       if status.source_media.status == SourceMediaStatus::CORRUPT or status.state == "posted"
#         resp_status[:deletable] = true
#       end
# 
#       if status.state == "posted"
#         resp_status[:favoritable] = true
#       end
# 
#       if profile
#         media = status.source_media.transcoded(profile)
#       else
#         media = status.source_media
#       end
# 
#       if status.source_media.status == SourceMediaStatus::HOSTED
#         resp_media = {:link => media.file_url,
#                       :web_thumb => status.source_media.web_thumb_url,
#                       :mob_thumb => status.source_media.mob_thumb_url,
#                       :type => SourceMediaType::STR[Integer(status.source_media.media_type)],
#                       :status => SourceMediaStatus::STR[Integer(status.source_media.status)]}
#       else
#         resp_media = {:link => nil,
#                       :web_thumb => nil,
#                       :mob_thumb => nil,
#                       :type => SourceMediaType::STR[Integer(status.source_media.media_type)],
#                       :status => SourceMediaStatus::STR[Integer(status.source_media.status)]}
# 
#       end
#       resp_status[:media] = resp_media
#       resp_status[:twitter_status_id] = twitter_status.tweet_id if twitter_status
#       resp_status[:facebook_status_id] = facebook_status.fb_status_id if facebook_status
      return resp_status
    end

    # Create a response timeline hash
    def response_timeline(statuses, profile, user = false)
      resp = []
      statuses.each do |status|
        resp << response_status(status, profile, user)
      end
      return resp
    end


    # Method to crete the response for the
    # user details

    def response_user(user)
      resp_user = {:id => nil, :username => nil, :user_avatar => nil, :user_avatar_medium => nil,:twit_user_avatar=>nil,:twit_username=> nil,
                   :fb_username=> nil,:bio => nil, :location => nil, :twitter => false, :facebook => false, :twitter_user_id => nil,:fb_user_id => nil,
                   :facebook_access_token => nil, :twit_access_token => nil, :twit_access_secret => nil}

      resp_user[:id] = user.id
      resp_user[:username] = user.username

     @user_meta_info = UserMetaInfo.find_by_user_id(user.id);
      if @user_meta_info
        resp_user[:location] = @user_meta_info.location
        resp_user[:bio] = @user_meta_info.bio
      end

      resp_user[:user_avatar] = DEFAULT_THUMBNAIL_URL
      resp_user[:user_avatar_medium] = DEFAULT_THUMBNAIL_URL

      for @twitter_user_info in user.twitter_user_infos
#        Changed for default image for tvider users
#        resp_user[:user_avatar] = @twitter_user_info.twit_profile_image
#        resp_user[:user_avatar_medium] = @twitter_user_info.twit_profile_image
        if @twitter_user_info.twit_access_token
          resp_user[:username] = user.username
          resp_user[:twitter] = true
          resp_user[:twitter_user_id] = @twitter_user_info.twit_user_id
          resp_user[:twit_username] = @twitter_user_info.twit_screen_name
					resp_user[:twit_access_token] = @twitter_user_info.twit_access_token
					resp_user[:twit_access_secret] = @twitter_user_info.twit_access_secret
          resp_user[:twit_user_avatar] = @twitter_user_info.twit_profile_image
        else
          resp_user[:username] = @twitter_user_info.twit_screen_name
        end
      end

      for @fb_user_info in user.facebook_user_infos
        if @fb_user_info.fb_access_token
          resp_user[:username] = user.username
          resp_user[:facebook] = true
          resp_user[:facebook_access_token] = @fb_user_info.fb_access_token
					resp_user[:fb_user_id] = @fb_user_info.fb_user_id
          resp_user[:fb_username] = @fb_user_info.fb_user_name
        end
      end

      @user_avatar = UserProfileAvatar.find_by_user_id(user.id)
      if @user_avatar
          resp_user[:user_avatar] = @user_avatar.user_avatar.url(:thumb)
          resp_user[:user_avatar_medium] = @user_avatar.user_avatar.url(:medium)
      end
      
      resp_user
    end

  # Method to handle the API exceptions
    def api_exception_handler(exception)
      logger.error exception
      @errors << exception.message
      @response[:code] = @response_codes[:internal_error]
    end


    # Create Comments response hash
    def response_comments(comments, user = false)
      resp = []
      comments.each do |comment|
        resp << response_comment(comment, user)
      end
      return resp
    end


    #Create a response status-Comment hash
    def response_comment(comment, user = false)
      resp_comment = {:text => nil, :id => nil,
                      :status_id => nil, :created_at => nil}
      resp_comment[:id] = comment.id
      resp_comment[:text] = comment.text
      resp_comment[:user] = response_user(comment.user)
      resp_comment[:created_at] = comment.created_at
      resp_comment[:status_id] = comment.status_update_id
      return resp_comment
    end


    # Create Abuse response hash
    def response_abuse(status, user = false)
      resp_abuse = {:abuse => nil, :id => nil}
      resp_abuse[:id] = status.id
      resp_abuse[:abuse] = status.abuse
      return resp_abuse
    end


    # Create Abuse response hash
    def response_views(status, user = false)
      resp_views = {:views => nil}
      resp_views[:views] = status.views
      return resp_views
    end


    # Create Favorite response hash
    def response_favorite(status, user = false)
      resp_favorite = {:favorite => nil, :id => nil}
      resp_favorite[:id] = status.id
      resp_favorite[:favorite] = status.favorite
      return resp_favorite
    end


    # Method for getting twitter instance
    def get_twitter_instance(twitter_user_info)

      # If token_secret_pair present then authenticate with twitter
      if twitter_user_info
        token = twitter_user_info.twit_access_token
        secret = twitter_user_info.twit_access_secret

        twitter_consumer = Twitter::OAuth.new(
                Utils::ConfReadUtil.read_yaml_token("twitter.yml", "consumer_token"),
                Utils::ConfReadUtil.read_yaml_token("twitter.yml", "consumer_secret"),
                {:site => Utils::ConfReadUtil.read_yaml_token("twitter.yml", "site")})


        twitter_consumer.authorize_from_access(token, secret)
        @twitter = Twitter::Base.new(twitter_consumer)

        # Verify credentials for all user data
        user = @twitter.verify_credentials

        if user
          user
          @twitter
        else
          @errors[:errorCode] = @response_codes[:incorrect_pass]
          @errors[:errorMessage] = @response_messages[:incorrect_pass]
          return nil
        end

      else
        @errors[:errorCode] = @response_codes[:incorrect_auth]
        @errors[:errorMessage] = @response_messages[:incorrect_auth]
      end
    end

  end
end